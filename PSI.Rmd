---
title: "PSI"
output: html_document
date: '2023-04-10'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#install.packages("scales")
#install.packages("ggplot2")
# install.packages("emdist")
library(readr)
library(data.table)
library(emdist)
library(ggplot2)
library(cluster)
#if (!require(factoextra)) {
#  install.packages("factoextra")
#}
library(stats)
```


# Binarization of the psi value 

This file has the aim to binarize the psi value into 0 and 1. 0 signifies that the exon is excluded whereby 1 signifies that the exon is included.

For that the script has different parts consisting of:
1. Read in events.csv file 
2. Create a histogram of every event 
3. Normalize the histograms and create a histogram matrix (histo_matrix) to store all the histogram values
4. Use a distance function (earth movers distance - emd) to calculate the distances of the histograms and create a distance matrix (emd_matrix). 
5. Use the k-means algorithm for the histogram matrix and the hierarchical clustering for the emd matrix. 
6. Cluster the histograms 


## 1. Read in events.csv file 

```{r}
# Read csv file into the data frame "events"
events <- read.csv("/nfs/home/students/a.schuhe/template/events.csv", header=TRUE)
# Show the first rows of the created data frame
head(events)
# Transpose data frame
events_t <- transpose(events)
# Redefine row and column names
rownames(events_t) <- colnames(events)
first_row <- events_t[1, ]
colnames(events_t) <- first_row
# select only the rows where the rowname starts with "IHECRE" 
events_t_IHEC <- events_t[grep("^IHECRE", rownames(events_t)), ]
head(events_t_IHEC)
```

## 2. Create a histogram of every event 
## 3. Normalize the histograms 
## 4. Use the distance function "earth movers distance" to calculate the distances of the histograms and create a distance matrix.

```{r}

# Create Histogram Plots (f.e. for the first event)
events_t_IHEC[ , 1] <- suppressWarnings(as.numeric(events_t_IHEC[ , 1]))

hist_p1 <- ggplot(events_t_IHEC, aes(x=events_t_IHEC[ , 1])) +
          geom_histogram(aes(y=..count../sum(..count..)), na.rm=TRUE, bins=40, breaks = c(-1/40, seq(1/40, 39/40, length.out=39), 41/40), binwidth=0.1, fill="lightblue", color="black") +
          # aes(y = ..density..) -> to normalize the histogram and to compute the histogram as densities (WICHTIG -> area darunter nicht 1) --> therefore
          # aes(y = ..count../sum(..count..)) to normalize the histogram and the highest y value is 1 and the area of all bars sums up to 1
          # breaks -> exactly one bin for 0 and 1 and 18 bins inbetween,
          # na.rm=TRUE -> missing values are silently removed
          # bins -> number of bins 
          # colour -> colour of the border line of the bars
          labs(title = sprintf("%s", names(events_t_IHEC[1])), x = "PSI value", y = "Density")

# ggsave(device="pdf", filename=sprintf("histogram_%s.pdf", names(events_t_IHEC[i])), p1)

hist_data_p1 <- ggplot_build(hist_p1)$data[[1]]
# the values of the midpoints of the bins are the same for every histogram 
bin_midpoints <- hist_data_p1$x 

# create an empty matrix (histo_matrix) to store the values of each histogram
histo_matrix <- matrix(0, nrow=length(events_t_IHEC), ncol=length(bin_midpoints), dimnames=list(colnames(events_t_IHEC), bin_midpoints))

for (i in 1:length(events_t_IHEC)) {
  print(i)
  SEorRI <- sub(".*;([[:alnum:]_]+):.*", "\\1", names(events_t_IHEC[i]))
  events_t_IHEC[ , i] <- suppressWarnings(as.numeric(events_t_IHEC[ , i])) 
  
  if(SEorRI == "SE") {
    colType <- "lightblue"
  } else {
    colType <- "lightpink"
  }
  
  histogram <- ggplot(events_t_IHEC, aes(x=events_t_IHEC[ , i])) +
          geom_histogram(aes(y=..count../sum(..count..)), na.rm=TRUE, bins=40, breaks = c(-1/40, seq(1/40, 39/40, length.out=39), 41/40), binwidth=0.1, fill=colType, color="black") +
          labs(title = sprintf("%s", names(events_t_IHEC[i])), x = "PSI value", y = "Density") 
  hist_data <- ggplot_build(histogram)$data[[1]]
  
  if (!is.null(hist_data$y)) {
    for (j in 1:40) {
    histo_matrix[i, j] <- hist_data$y[j]
    } 
  }
}
 
write.csv(histo_matrix, file = "/nfs/home/students/a.schuhe/scripts/splicingREMs/histo_matrix.csv") #, row.names = TRUE, col.names = TRUE, sep = ',')

# create an empty matrix (emd_matrix) to store the EMD distances
emd_matrix <- matrix(0, nrow = length(events_t_IHEC), ncol = length(events_t_IHEC), dimnames=list(colnames(events_t_IHEC), colnames(events_t_IHEC)))

# calculate the EMD distance for each pair of histograms
for (i in 1:length(events_t_IHEC)) {
  print(i)
  hist_data_p1 <- histo_matrix[i,]
  
  begin <- Sys.time()
  for (j in i:length(events_t_IHEC)) {
    if (i!=j){
      hist_data_p2 <- histo_matrix[j,]
      if (!is.null(hist_data_p1[1]) & !is.null(hist_data_p2[1])) {
        A <- matrix(c(hist_data_p1, bin_midpoints), ncol = 2)
        #print(dim(A))
        B <- matrix(c(hist_data_p2, bin_midpoints), ncol = 2)
        #print(dim(B))
        # calculate the EMD distance
        emd_dist <- emd(A, B)
      
        # store the EMD distance in the matrix
        emd_matrix[i, j] <- emd_dist
        emd_matrix[j, i] <- emd_dist
      }
    }
  }
  end <- Sys.time()
  print(end-begin)
}

emd_matrixTest <- emd_matrix
for (i in 1:length(emd_matrix)) {
  if (!is.nan(emd_matrix[i,])) {
    emd_matrixTest = emd_matrix[-i, ]
  }
}

write.csv(emd_matrix, file = "/nfs/home/students/a.schuhe/scripts/splicingREMs/emd_matrix.csv") #, row.names = TRUE, col.names = TRUE, sep = ',')

```


# 5. Use the k-means algorithm for the histogram matrix and the hierarchical clustering for the emd matrix.
# 6. Cluster the histograms

```{r}

##TEST##---------------------------##---------------------------##---------------------------##---------------------------
cluster(histo_matrix)

library(factoextra)
#install.packages('factoextra')

# Enhanced k-means clustering
#res.km <- eclust(df, "kmeans", nstart = 25)
#install.packages('tidyverse')
library(tidyverse)
k1 <- kmeans(histo_matrix, centers = 3)
k1
##---------------------------##---------------------------##---------------------------##---------------------------##---------------------------

# Hierarchical clustering with the emd matrix (emd_matrix)
emd_dist_matrix <- emd_matrix

'm <- emd_dist_matrix + t(emd_dist_matrix) - diag(emd_dist_matrix)

m# Check if the matrix is symmetric
all(m == t(m))

# Remove duplicated values
m[lower.tri(m)] <- NA
m <- m[!duplicated(m),]

# Convert to distance matrix
d <- as.dist(m)
'


emd_dist_matrix[is.nan(emd_dist_matrix)] <- NA
dim(emd_dist_matrix)
diag(emd_dist_matrix) <- 0
emd_dist_matrix <- as.dist(emd_dist_matrix)
View(emd_dist_matrix)
dim(emd_dist_matrix)
# The complete linkage method finds similar clusters.



######
#emd_hclust_matrix -> die Matrix inkludiert die Distanzwerte (mit emd() berechnet) -> daher nicht dist Funktion aufrufen, aber die Matrix muss in der Form einer dist Matrix sein 
# Next Step: emd_hclust_matrix in dist Matrix Form transformieren 
# Next Argument: Dimension der erzeugten dist Matrix darf nicht größer als 65536 observations sein 
# Next Step: Aufteilen der erzeugten dist Matrix in unterschiedliche subsets, damit observations Größe eingehalten wird 

emd_hclust_matrix <- emd_matrix
emd_hclust_matrix[is.nan(emd_hclust_matrix)] <- 0
diag(emd_hclust_matrix) <- 0
emd_hclust_matrix <- as.matrix(emd_hclust_matrix)
emd_dist_hclust <- as.dist(emd_dist_matrix)
emd_dist_hclust <- as.matrix(emd_dist_hclust) #I don't really know if this is needed to apply hclust 

# Define the number of rows in each subset
subset_rows <- 10

# Split the matrix into a list of smaller matrices
emd_dist_hclust_Split <- split(emd_dist_hclust, rep(seq(1, nrow(emd_dist_hclust), subset_rows), each=subset_rows)[seq_along(emd_dist_hclust)])

# Print the dimensions of the first subset
print(dim(emd_dist_hclust_Split[1]))

# TODO: transform lis

#emd_hclust_matrix <- emd_matrix[complete.cases(emd_matrix), ]
#dim(emd_hclust_matrix) #-> in jeder Zeile existiert anscheinend mind. 1 NA 
system.time(hcluster_emd <- hclust(emd_hclust_matrix, method = "complete"))


```

