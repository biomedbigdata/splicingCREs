---
title: "PSI"
output: html_document
date: '2023-04-10'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#install.packages("scales")
#install.packages("ggplot2")
# install.packages("emdist")
library(readr)
library(data.table)
library(emdist)
library(ggplot2)
library(cluster)
if (!require(factoextra)) {
  install.packages("factoextra")
}
library(stats)
```


# Binarization of the psi value 

This file has the aim to binarize the psi value into 0 and 1. 0 signifies that the exon is excluded whereby 1 signifies that the exon is included.

For that the script has different parts consisting of:
1. Read in events.csv file 
2. Create a histogram of every event 
3. Normalize the histograms 
4. Use a distance function (earth movers distance, Kullback Leider distance, Wasserstein distance) to calculate the distances of the histograms and create a distance matrix. 
5. Use the k-means algorithm 
6. Cluster the histograms 


## 1. Read in events.csv file 

```{r}
# Read csv file into the data frame "events"
events <- read.csv("/nfs/home/students/a.schuhe/template/events.csv", header=TRUE)
# Show the first rows of the created data frame
head(events)
# Transpose data frame
events_t <- transpose(events)
# Redefine row and column names
rownames(events_t) <- colnames(events)
first_row <- events_t[1, ]
colnames(events_t) <- first_row
# select only the rows where the rowname starts with "IHECRE" 
events_t_IHEC <- events_t[grep("^IHECRE", rownames(events_t)), ]
head(events_t_IHEC)
```

## 2. Create a histogram of every event 
## 3. Normalize the histograms 
## 4. Use the distance function "earth movers distance" to calculate the distances of the histograms and create a distance matrix.

```{r}


events_t_IHEC[ , 1] <- suppressWarnings(as.numeric(events_t_IHEC[ , 1]))
#geom_histogram(breaks = c(0, seq(1/18, 17/18, by = 1/18), 1))
hist_p1 <- ggplot(events_t_IHEC, aes(x=events_t_IHEC[ , 1])) +
          geom_histogram(aes(y=..count../sum(..count..)), na.rm=TRUE, bins=40, breaks = c(-1/40, seq(1/40, 39/40, length.out=39), 41/40), binwidth=0.1, fill="lightblue", color="black") +
          # aes(y = ..density..) -> to normalize the histogram and to compute the histogram as densities (WICHTIG -> area darunter nicht 1) --> therefore
          # aes(y = ..count../sum(..count..)) to normalize the histogram and the highest y value is 1 and the area of all bars sums up to 1
          # breaks -> exactly one bin for 0 and 1 and 18 bins inbetween,
          # na.rm=TRUE -> missing values are silently removed
          # bins -> number of bins 
          # colour -> colour of the border line of the bars
          labs(title = sprintf("%s", names(events_t_IHEC[1])), x = "PSI value", y = "Density")
hist_data_p1 <- ggplot_build(hist_p1)$data[[1]]
print(hist_data_p1)
bin_midpoints <- hist_data_p1$x #the values of the midpoints of the bins are the same for every histogram 

# create an empty matrix to store the values of each histogram
histo_matrix <- matrix(0, nrow=length(events_t_IHEC), ncol=length(bin_midpoints), dimnames=list(colnames(events_t_IHEC), bin_midpoints))

for (i in 1:length(events_t_IHEC)) {
  print(i)
  SEorRI <- sub(".*;([[:alnum:]_]+):.*", "\\1", names(events_t_IHEC[i]))
  events_t_IHEC[ , i] <- suppressWarnings(as.numeric(events_t_IHEC[ , i])) 
  
  if(SEorRI == "SE") {
    colType <- "lightblue"
  } else {
    colType <- "lightpink"
  }
  histogram <- ggplot(events_t_IHEC, aes(x=events_t_IHEC[ , i])) +
          geom_histogram(aes(y=..count../sum(..count..)), na.rm=TRUE, bins=40, breaks = c(-1/40, seq(1/40, 39/40, length.out=39), 41/40), binwidth=0.1, fill=colType, color="black") +
          # aes(y = ..density..) -> to normalize the histogram and to compute the histogram as densities (WICHTIG -> area darunter nicht 1) --> therefore
          # aes(y = ..count../sum(..count..)) to normalize the histogram and the highest y value is 1 and the area of all bars sums up to 1
          # breaks -> exactly one bin for 0 and 1 and 18 bins inbetween,
          # na.rm=TRUE -> missing values are silently removed
          # bins -> number of bins 
          # colour -> colour of the border line of the bars
          labs(title = sprintf("%s", names(events_t_IHEC[i])), x = "PSI value", y = "Density") 

  # ggsave(device="pdf", filename=sprintf("histogram_%s.pdf", names(events_t_IHEC[i])), p1)
  # TODO: Should I save all the histograms? -> My idea: save only 3-4 to demonstrate on the poster what I've done 
  hist_data <- ggplot_build(histogram)$data[[1]]
  
  if (!is.null(hist_data$y)) {
    for (j in 1:40) {
    histo_matrix[i, j] <- hist_data$y[j]
    } 
  }
}
 
write.csv(histo_matrix, file = "/nfs/home/students/a.schuhe/scripts/splicingREMs/histo_matrix.csv") #, row.names = TRUE, col.names = TRUE, sep = ',')
cluster(histo_matrix)

library(factoextra)
install.packages('factoextra')

# Enhanced k-means clustering
#res.km <- eclust(df, "kmeans", nstart = 25)
install.packages('tidyverse')
library(tidyverse)
k1 <- kmeans(histo_matrix, centers = 3)
k1

# create an empty matrix to store the EMD distances
emd_matrix <- matrix(0, nrow = length(events_t_IHEC), ncol = length(events_t_IHEC), dimnames=list(colnames(events_t_IHEC), colnames(events_t_IHEC)))

# calculate the EMD distance for each pair of histograms
for (i in 1:length(events_t_IHEC)) {
  print(i)
  hist_data_p1 <- histo_matrix[i,]
  
  begin <- Sys.time()
  for (j in i:length(events_t_IHEC)) {
    if (i!=j){
      hist_data_p2 <- histo_matrix[j,]
      if (!is.null(hist_data_p1[1]) & !is.null(hist_data_p2[1])) {
        A <- matrix(c(hist_data_p1, bin_midpoints), ncol = 2)
        #print(dim(A))
        B <- matrix(c(hist_data_p2, bin_midpoints), ncol = 2)
        #print(dim(B))
        # calculate the EMD distance
        emd_dist <- emd(A, B)
      
        # store the EMD distance in the matrix
        emd_matrix[i, j] <- emd_dist
        emd_matrix[j, i] <- emd_dist
      }
    }
  }
  end <- Sys.time()
  print(end-begin)
}

# print the EMD distance matrix
emd_matrix


```


