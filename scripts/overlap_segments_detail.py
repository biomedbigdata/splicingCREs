#!/usr/bin/env python3# File paths

# for example: "RI:chr1:3630767:3631117-3631466:3631657" (RI: s1:e1-s2:e2) or "SE:chr1:3630767-3631117:3631466-3631657" (SE: e1-s2:e2-s3) 

# 3630500-3631300: overlapping
# 3630500-3631100: overlapping upstream adjacent 
# 3630500-3630700: upstream
# 3631500-3631700: overlapping downstream adjacent
# 3631700-3631900: downstream 

import pandas as pd
import glob
from scipy.stats import spearmanr
import os


root_folders = [
    "/nfs/home/students/a.schuhe/scripts/splicingREMs/output_STITCHIT/H3K27ac",
    "/nfs/home/students/a.schuhe/scripts/splicingREMs/output_STITCHIT/H3K27me3",
    "/nfs/home/students/a.schuhe/scripts/splicingREMs/output_STITCHIT/H3K36me3",
    "/nfs/home/students/a.schuhe/scripts/splicingREMs/output_STITCHIT/H3K4me1",
    "/nfs/home/students/a.schuhe/scripts/splicingREMs/output_STITCHIT/H3K4me3",
    "/nfs/home/students/a.schuhe/scripts/splicingREMs/output_STITCHIT/H3K9me3"
]

# Column names for the dataframes
columns = ['Event', 'Event type', 'Total Amount of IHEC Entries', 
           'Amount Segments total', 'Amount Significant Segments Spearman', 
           'Upstream', 'Overlapping Upstream Adjacent', 'Overlapping Upstream Adjacent + RoI', 'Overlapping Total Up-Down',
           'Overlapping Downstream Adjacent + RoI', 
           'Overlapping Downstream Adjacent', 'Downstream', 'Overlap General', 'Significant Segments Spearman',
           'Class'] 

# Significant Segments Spearman -> amount of significant segments (calculated with spearman and alpha as a threshold)
# Significant Segments Pearson -> amount of significant segments (caluclated with pearson and alpha as a threshold)

df_HM_Overlap_SegSpearman = pd.DataFrame(columns=columns)

for root_folder in root_folders:
    for root, dirs, files in os.walk(root_folder):
        number_file_processed = 0
        print(f"PROCESSING THE ROOT FOLDER {root_folder}")
        for file in files:
            number_file_processed = number_file_processed+1
            print(f'i:{number_file_processed}')
            print(f'file:{file}')
        
            
            histone_modi = root_folder.rstrip().split("/")[5]
            segmentation_filepath = os.path.join(root, file)
            segmentation_filename = segmentation_filepath.rstrip().split("Segmentation")[1]
            eventID = segmentation_filepath.rstrip().split("_")[2] #number of the event 
            wildcard_event_id_complete_filepath = "/nfs/home/students/a.schuhe/scripts/splicingREMs/splicingREMs/output_continous/" + f'{eventID}' + "*" + f'{histone_modi}.txt'
            wildcard_event_id_complete = glob.glob(wildcard_event_id_complete_filepath)[0]
            event_id_complete = wildcard_event_id_complete.rstrip().split("/")[5]
            event_type = event_id_complete.split("_")[2].split(":")[0] #SE or RI 
            
            #f.e. 000000000000001_ENSG00000000457.13_SE:chr1:169854964-169855796:169855957-169859041:-_H3K27ac.txt
            #SE: e1-s2:e2-s3
            
            #f.e. 000000000000008_ENSG00000005238.19_RI:chr9:35107381:35107568-35108128:35108349:-_H3K9me3.txt
            #RI: s1:e1-s2:e2

            
            if(event_type == "SE"):
                pre_e1 = event_id_complete.split(":")[2]
                pre_e2 = event_id_complete.split(":")[3]
                a1 = pre_e1.split("-")[0] #e1
                a2 = pre_e1.split("-")[1] #s2
                a3 = pre_e2.split("-")[0] #e2
                a4 = pre_e2.split("-")[1] #s3
                #Region of interest: a2-a3
            else:
                pre_s1 = event_id_complete.split(":")
                a1 = pre_s1[2] #s1
                a2 = pre_s1[3].split("-")[0] #e1
                a3 = pre_s1[3].split("-")[1] #s2
                a4 = pre_s1[4] #e2
                #Region of interst: a2-a3
            
            p_or_s = segmentation_filename.rstrip().split("_")[3]
            p_or_s = p_or_s.rstrip().split(".")[0]
            
            if(p_or_s == "Pearson"): 
                continue
        
            skip_eventID =  ['000000000000010', '000000000000100', '000000000000101', '000000000000102', '000000000000103', '000000000000104', '000000000000105', '000000000000106', '000000000000107', '000000000000108', '000000000000210', '000000000000310', '000000000000410', '000000000000505','000000000000510', '000000000000565', '000000000000610', '000000000000659','000000000000676'] #skip the eventIDs where the Segmentation_..._Pearson.txt and Segmentation_..._Spearman.txt output files (generated by STITCHIT) have different segments -> checked with the code: size_check.py
            
            if eventID not in skip_eventID:

                processing_file = f'{histone_modi}_' + file
                print("Processing the file:" + processing_file )
                
                #Perform operation on each file
                with open(segmentation_filepath, 'r') as seg_file: #, open(output_filepath,'w') as output_file:

                    segments = seg_file.readline().rstrip().split("\t")
                    amount_of_segments_ALL = len(segments) #INCLUDING the first element '' that indicates the rowname column and 'Expression' that indicates the PSI value column  --> real amount of segments = len(segments)-2
                    amount_of_computed_segments = len(segments)-2 #EXCLUDING the first element '' that indicates the rowname column AND 'Expression' that indicates the PSI value column  
                    
                    segment_vectors = [[] for i in range(amount_of_segments_ALL)] #it generates a sequence of numbers from 0 to amount_of_segments_ALL-1. It creates amount_of_segments_ALL empty lists (And it will iterate from 0 to amount_of_segments_ALL-1 (inclusive). There is a '-1' behind 'amount_of_segments_ALL' because the list starts with the indicator [0] 

                    lines = seg_file.readlines()

                    for line in lines:
                        line = line.rstrip().split("\t")
                        segment_vectors[0].append(line[0]) #segment_vectors[0] includes all the rownames (...fc.signal files) -> string remains unchanged

                        for i in range(1,amount_of_segments_ALL): #for each element in a row, 0->IHEC Entry identicator (first column), amount_of_segments_ALL-1-> Last column for PSI values (because the segments list starts with [0] for the IHEC entry identicators)
                            segment_vectors[i].append(float(line[i]))
                            


                    #segment_vectors[0] includes the rownames (...fc.signal filenames)
                    #segment_vectors[1] includes all the column values for the first segment
                    #segment_vectors[2] includes all the column values for the second segment
                    #etc.

                    psi_values = segment_vectors[amount_of_segments_ALL-1] #the last column is the indicator for the psi values (you have to calculate amount_of_segments_ALL-1 because there is a list with the indicator [0])
                        
                    amount_significant_spearman = 0                    
                    significant_segments_spearman = []

                    for i in range(1,amount_of_segments_ALL-1): #go through every segment column and check whether the p value for the segment is significant or not; only until amount_of_segments_ALL-1 to exclude the 'Expression' (PSI value) column
                        if(len(segment_vectors[0]) != len(segment_vectors[i])): #check if everything is correct respectively the amounts of rows and values in the segment column
                            print("There is a different amount of values in the lists.")
                            break

                        #calculate correlations
                        rho, p_value_spearman = spearmanr(segment_vectors[i], psi_values)
                        alpha = 0.05
                                                
                        #calculate length of the segment (does not depend on SE or RI)
                        segment_list = segments[i].rstrip().split(":")

                        if (p_value_spearman < alpha):#ignore the p values with a value bigger than alpha
                            amount_significant_spearman = amount_significant_spearman+1
                            significant_segments_spearman.append(segments[i])


                    
                    #quick sanity check 
                    if (len(significant_segments_spearman) == amount_significant_spearman):
                        pass
                    else:
                        print("The lengths of the significant segments is different. Look at your code!")
                        break
                    
                    upstream = 0
                    overlap_upstream_adj = 0 
                    overlap_total_up_down = 0 
                    overlap_upstream_adj_roi = 0 
                    overlap_downstream_adj_roi = 0
                    overlap_downstream_adj = 0
                    downstream = 0 
                    overlap_general = 0
                    rest = 0
                    
                    for seg in significant_segments_spearman:
                        seg = seg.split(":")
                        start_seg = seg[1].split("-")[0]
                        end_seg = seg[1].split("-")[1]
                        
                        #upstream
                        if(end_seg<a1):
                            upstream = upstream+1
                        elif(end_seg>=a1 and end_seg<a2):
                            overlap_upstream_adj = overlap_upstream_adj+1
                        elif(start_seg<=a2 and end_seg>=a3):
                            overlap_total_up_down = overlap_total_up_down+1
                        elif(start_seg<=a2 and end_seg<=a3 and end_seg>=a2):
                            overlap_upstream_adj_roi = overlap_upstream_adj_roi+1
                        elif(start_seg>=a2 and start_seg<=a3 and end_seg>=a3):
                            overlap_downstream_adj_roi = overlap_downstream_adj_roi+1
                        elif(start_seg>=a3 and start_seg<a4):
                            overlap_downstream_adj = overlap_downstream_adj+1
                        elif(start_seg>a4):
                            downstream = downstream+1
                        elif(start_seg<=a3 and end_seg>=a2):
                            overlap_general = overlap_general+1
                        else:
                            rest = rest+1
                            
                    #'Region of interest'                   
                    #for later, include: Which segments? How many overlapping? Which ones are overlapping? How many Upstream or Downstream or Included? Which ones are Upstream or Downstream or Included? Those which are not overlapping -> print + Which difference do they have to the region of interest?
                    #Appending data to the current DataFrame
                    data = {
                        'Event': event_id_complete,
                        'Event type': event_type,
                        'Total Amount of IHEC Entries': len(segment_vectors[0]),
                        'Amount Segments total': amount_of_computed_segments,
                        'Amount Significant Segments Spearman': amount_significant_spearman,
                        'Upstream': upstream,
                        'Overlapping Upstream Adjacent': overlap_upstream_adj,
                        'Overlapping Upstream Adjacent + RoI': overlap_upstream_adj_roi,
                        'Overlapping Total Up-Down': overlap_total_up_down,
                        'Overlapping Downstream Adjacent + RoI': overlap_downstream_adj_roi,
                        'Overlapping Downstream Adjacent': overlap_downstream_adj,
                        'Downstream': downstream,
                        'Overlap General': overlap_general,
                        'Rest': rest,
                        'Sum': upstream+overlap_upstream_adj+overlap_upstream_adj_roi+overlap_total_up_down+overlap_downstream_adj_roi+overlap_downstream_adj+downstream,
                        'Significant Segments Spearman': significant_segments_spearman,
                        'Class': histone_modi
                    }
                    
                    
                    
                    if p_or_s == "Spearman":
                        df_HM_Overlap_SegSpearman = df_HM_Overlap_SegSpearman.append(data, ignore_index=True)
            else:
                print(f'For the event ID {eventID} the generated Segmentation_..._Pearson.txt and Segmentation_..._Spearman.txt output files (by STITCHIT) do not match in the computed segments.')
                print("There is no output file generated for: " + event_id_complete )

df_HM_Overlap_SegSpearman.to_csv('/nfs/home/students/a.schuhe/scripts/splicingREMs/output_CorrelationShuffle/df_HM_Overlap_SegSpearman.csv', index=False)



